# Software as a first class research output in a FAIR ecosystem
**by Morane Gruenpeter**  

## From session 1 - [Sustaining software in cultural heritage](/wosss21/agenda#session-1)  

### Resources

A [video](https://www.youtube.com/watch?v=iQ41V05Rlqc&list=PLXAvKzjdTsrxFqbjWtxHjfJc0RN6jMwZg&index=7) is and [slides](https://docs.google.com/presentation/d/12pog7Qh8IPO5Y2u8-_ngMysAz2M2ZiHxYoyJmUqPBHs/edit?usp=sharing) are available.

### Summary

Software is a significant and vital component of research. It is integral to all stages of research and can play the role of a tool, a research result, or a research object. Since software source code has been recently recognised as an important asset also in the field of scientific research, complementing publications and research data, it is essential to collect and preserve it.

Software Heritage (SWH) is the universal source code archive, collecting, preserving and sharing the largest collection of source code.  Software Heritage is now providing the infrastructure for depositing and referencing software source code, in collaboration with national and international open access portals.

In parallel, the RDA & ReSA and FORCE11 working group FAIR for Research Software has identified divergences between software and data and the crucial need to translate the FAIR data principles to be relevant for software artifacts. In September 2021 the working group published [the first version of the FAIR for Research Software principles](https://doi.org/10.15497/RDA00065) after a community review.

Finally, the importance of [archiving, referencing, describing and citing software](https://doi.org/10.2777/28598) is a common goal to have better recognition and interoperability of software in a FAIR ecosystem.

### Transcript

So my presentation is called software as a first class output in a fair ecosystem. And I will cover a few different subjects. So I have a few different hats on today. So I'm a software engineer and the metadata specialist in the software heritage initiative at the InRIA Research Centre in Paris, France. I'm also representing the Inria Research Centre on the FAIRsFAIR European project. And I'm also a co chair of the joint RDA ReSA and FORCE11 FAIR research software working group. And I'm kind of going to propose to you a presentation today that will cover different subjects that will kind of integrate software preservation, research software, and fair fair software. So let's go and jump into this presentation. So first, with a short introduction of research software as a first class output, then why research software archiving is important. I will continue with the software heritage universal source code, archive and software in a fair ecosystem. And finally, I will also show you some of the work we are doing on the fair for research software working group show you how all these dots are connected and are important. So first, software in research has multiple facets as well like my role here, software is also have different roles. It can be a tool, it can be a research outcome of the research process. And it can be the object of research. It is important to make it a first class output which is in the process of being a first class I'll do this in a few years ago, we would say that it wasn't and it was a forgotten pillar next to the publications in open access repository and data sets in the open data set repositories that software is forgotten, but now it's becoming more and more on as a first class a first class output. The just to show us a few a few examples of important landmarks in research software and software. Importance of software, software source code is also very special. 
And it's not it's not just data evolves over time and projects may last decades. The key to its understanding is the history of development. It can be very complex from few lines of code with many lines of code as well. And it may have a lot of levels of pendency, though, so talking about one software might not be talking about all the requirements that the software really needs to be maintained and sustained. For the long term, it might have a softer, sophisticated developer community. This is why it is important to preserve the source code because the source code is human readable. And it is executable knowledge. programmes must be written for people to be read. And only incidentally for machines to execute. The source code provides a view into the mind of the designer. It's important to keep this in mind even if we want to reuse software and mostly when we want to reuse software might be a very machine execute executable. The knowledge is in the source code and why are we here there are a plurality of needs in the scholarly ecosystem where researchers need to reference their software to get credit for the software to find useful software and to verify reproduce results. The laboratories of those teams and teams want to track software contributions and produce reports and finally the Research Organisation they want to know their software assets and this is part of an scholarly ecosystem that we want to make also fair a fair ecosystem. And this is important recess of archiving is important but why? Because it can be lost. It is fragile, it can be damaged as different ways for it to be
to not stay where it was yesterday. So some exam And be destroyed. For example, Google's killed Google Code. And Bitbucket decided to sunset, the Mercurial support just last year. And luckily, Software Heritage was here to take apart in this continuation of the access to the source code. So hosting your open source project is on a free publicly available preference platform is completely fine. And it's good, it's good that you will do that because it is important to to have it in public repository if you have open source software. But you have to prepare a plan B. and why it's important to prepare a plan B. Also, because the version for systems changes. Now the most popular I don't have it onto this slide. But we did an analysis most popular in Git. We had some different version control system before Git. And we might have different version control system after Git. So we need to address this also when we archive source code. And this is why I want to present to you software heritage with the aim to collect, preserve and share all software source code to preserve the heritage, enabling better software and better research for all. So if you see these charts, they were taken in June 2021. We have grown since 2016 when software heritage has just launched. And we have now more than 161 million projects. I'm not going to click on this link even I've wanted to do a tour but I don't have the time. So I'm going to just tell you a few things. Software heritage is archiving different forges package managers, and even scholarly repositories like how and publisher like I put the iPod journal. Software Heritage is rescuing software told you before soft source code is fragile. And Google Code is now safely in software heritage, also the Mercurial repositories. And saving code is for everyone. It's not only for your code, saving your code, but also saving other people's code. Because like the Internet Archive, you can just use a URL on this save code now interface. And it will fetch the publicly available code into software heritage, the same way it does with web pages for the Internet Archive, the advantages it, it's saving the complete development history. And you can use different URLs from different platforms, git, Mercurial and svn types of repositories. And then you can use suede, which is a persistent identifiers, also heritage persistent identifier, which is intrinsic. It's like a digital fingerprint of the object itself. And you can reference very different parts in the different granularities of your source code or for any other source code that it's that is archived on soft heritage. These identifiers are decentralised they do not need a registry, you can also compute them on your machine if you want to sweet companies after heritage for that. And they are cryptographically strong identifiers. So this is the end of the preservation part. In the software heritage part of my presentation, there are so many things I want to tell you that you should go to the archive and discovered by the stuff we have very nice how to guide, I've put a link in the notes we also have for cultural heritage, we have the software heritage acquisition process, which is specifically for legacy software. But I didn't have the time to tell you all about that today. So go You have many things to discover there. 

And moving on to the fair ecosystem. With my first fair hat on we want to build a bridge, a bridge or many bridges between these communities, between software development communities and research software communities and the fair communities which are have the same goal to improve software curation and quality Software. As I said before, in the beginning software is not just another type of data, we have these two recommendations that

support that, we need to recognise that the fair guidelines, the guiding principles should be translated to other digital objects. And make sure the specific nature of software is recognised, and not considered as just data, particularly in the context of discussion, but the notion of fair data. And we want it to be known that software is ever in the fair ecosystem. If you look at this nice image of the federal court system, you can see a few icons that I've used for suggesting their software, their software is behind a lot of things. It's behind services is behind repositories, to have a repository running its software that's behind it, that registries or software is behind it. But there's the digital objects, which are the software outputs, and somewhere next to that there is the tools that are not the research outputs, but are used during the research. So software is really everywhere. And we need to keep that in mind. And the complexity of software is also important to keep in mind. Last year, we've done in FAIRsFAIR, a report the assessment report on fairness of software and a webinar, decoding different principles did every work. That was very useful during our work as the fair for research software Working Group, which I'm going to come to now. So with my third hat on the fair for research software Working Group assign. I'm a co-chairs, but we're many co-chairs very each of us is contributing to this working group actively and I really want to acknowledge each Working Group chair Paula, Carlos, Michelle, Dan, Layla, Neil, Fortis and Jen, and also acknowledged all the almost 228, it was a few weeks ago, it was 228 members that have contributing to the this working group. The timeline started in September 2020, when it was endorsed by RDA. So I started it in the beginning, but I'm going to repeat it. It's a joint working group of force 11 and the RDA. And it is a task force between September 2020. And let's say March 2021. The subgroups 1, 2, 3 and 4 worked, I'm not going to detail that because I don't want to take up too much time this work has ended, you can see a lot of things that we have done on the RDA page. And we have many teachers out there, including one time going to show you in the next slide a FAIR for Research Software webinar, which is much more detailed than what I'm going to tell you today. And recently in June, we have released the FAIR for Research software principles which I will show you in the next few slides. And now we started the five the fifth sixth and seventh subgroups, which are more focused on adoption and yet, I will discuss that in in the next slide. So first, the development of the FAIR for research software principles. The intent and methods of the third guiding principles took two points as starting points, we wanted to maximise the added value gain by contemporary foremost quality digital publishing and make software a first class output alongside publications and data. And another starting point was to ensure transparency represent reproducibility and reusability, which is a very focal focal point of the fair for research software principles because our is we use the definition of reuse is a bit more complicated with software. The fair principles are aspirational and fair is not binary. So it's not you are fair or not fair. We aim to improve software and the research or scholarly ecosystem by having fair, fairer software. But it's not binary. Software encompasses many form which may benefit different users. So there's the users the end the creators, there's the people that depends on the software for example, different creations, that are

required to Run specific software. And as I said in the beginning, the knowledge in is in the source code. So it is often the most useful form to understand the software, and also the easiest form to apply the fair for research software principles. And many software engineering practices are relevant to the fair for research software principles of the here is the bridge between those communities. We want this to be aligned not to create a divergence between those communities, but really work together to improve software and research. So this slide is very packed, and I'm not going to read it. It's the FAIR principles for research software as we're defined by the FAIR for research software working group in this 2021 publication, which is available online on the webpage. It's also described and discussed thoroughly. In the FAIR 4 Research Software system software webinar, here is the link, I also put the link in the notes of the collaborative notes. Um, I think that people that know the fair principles will see that the differences are not major. But there are some interesting facts that can be taken into consideration. Specifically, the Fair to software includes qualified represent to other software, which is completely new, in the respect of the fair data principles. But again, I will let you read that calmly in your own time, and maybe watch the fair for research software webinar, which was very, very nicely where it's very nicely described by Neil Chue Hong, and then there's also calls and then that have a part of that webinar describing the working group and activities. And we know that fair is as a specific part to improve software. But fair is not the end goal. It is a step in as it is not binary. Also, the end goal isn't binary. And there are many steps were to this end goal where all software is robust. All software is reproducible, all software is sustainable. And all software or all, most software is also open source. And finally, all software source code is archived, maybe a scholarly archive, but also on software heritage. So there are steps that are beyond fair that can't be included in the fair principles. To get engagement in the fair for research software working group, we have this three new subgroups that started in the beginning of September. So it's still you have to time to join if you want to. We have subgroup five. Working on adoption guidelines, identify create review existing resources that facilitate the adoption of the fair for research software principles. We have subgroup six, about adoption support. I then identify and start work with organisation following the fair for research software guidelines. Stimulate adoption of the fair for research software guidelines and document and share example of these adoptions and plans. And finally, there's subgroup seven about governance to create communications plan and content, that cover post release governance structure. So you can join in this forum or directly email one of the chairs of each one of these, suppose there's a lead for each one of these subgroups, or two leads. It's not written here, but all the information is available on the RDA page. And in this and you can also use this form and come and join the effort. 

So to wrap up, I did it quick, quicker than I expected. I felt like if someone fire behind me, so I'm sorry if it was too quick. But I think that you got everything that I wanted to say today even though there are many things that I want to say to you. And I didn't have the time or I didn't think that you have the time to tell him about but maybe in the next presentation for now to wrap up. What's important is to archive source code as much as possible. Software heritage is doing that proactively. So there are many repositories out there that are proactively archived in software heritage, don't just need to do a safe code now. But the safe code now is kind of putting its up. So we'll do it quicker in a few minutes in and not come to it after a long, weeks and months. So this is important to know. The second point from this talk is that you should or if you are interested in February, Saturday, you can join the working group, even if it's just a read the emails and receive the updates, you can be more active and contribute to the subgroups work and follow, there's a lot of events where the working with is presenting where we get feedback from the community. So you should follow that and come in on. The third point is to adopt good practices to develop fair software. So I didn't show a lot of good practices, even though I'm a metadata specialist, and I could have shown you some good practices about metadata, but I will give you two vocabularies that you should follow. You should follow CodeMeta, and you should follow Citation.cff. And if you have one or both in your repository, then I will be happy when citing or needing metadata for indexing because we are indexing both files in files in software heritage. So metadata is something important. And finally, let's spread the word as a community and start, even if we already started but continue recognising software in academia. Thank you. Thank you very much for inviting me and I hope to see you soon

