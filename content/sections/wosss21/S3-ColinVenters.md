# The Lost Architectures of Scientific Software and How to Find Them
**by Colin Venters**  

## From session 3 - [Human factors and new development in preserving and sustaining research software](/wosss21/agenda#session-3)  

The definitive write-up of this talk appears in the [WoSSS21 report](https://wosss.org/#reports).

### Resources
A [video](https://www.youtube.com/watch?v=yLYlUNY2kG8&list=PLXAvKzjdTsrxFqbjWtxHjfJc0RN6jMwZg&index=17) is available.

### Transcript

#### Keywords

architecture, software, architectural, sustainable, merlin, sustainability, maintainable, technical debt, leeds, quality, designed, university, tangled mess, understand, building, field, working, software engineering, software architecture, research

#### Text

My name is Colin, I'm from the University of Huddersfield. If you've looked in the sort of introduction section, you'll find out stuff about me. Two things I probably want to flag is that I am a founding member of the Karlskrona. manifesto, and co author of the, the manifesto that came out for XC. Zen would talk about the last architectures of scientific software and perhaps how we can find them. So I wanted to kind of begin this story a little bit around where my journey began. And I used to work at the University of Leeds many moons ago. And I decided I wanted a change of direction in both career and in some things, I was doing research. But I went the long distance across the Pennines, the University of Leeds working in the dependable Systems and Software Group. And I was working on a military project, which was about network centric warfare. But it was really a project about sustainability, but not sustainability in terms of how we think about sustainability. So we were thinking about things to do with lethality, we were thinking about quality, such as survivability of weapon systems, and the University of Leeds were principally responsible for thinking about how we architected this system, and how we were able to utilise and make more efficient use of different types of resources. So that's where my sort of journey in the field of sustainability really begins. There was an interesting blog post posted on the RSE Slack channel, some while ago, and it was entitled The shape of cool got tangled mess, or at least it was hinting at a tangled mess. And it was someone's position that research software, indeed, was a tangled mess. And that research software engineering would make no difference to this particular problem. What was quite interesting about that was from both positions, it was difficult to either support that position or refute it. There is always some kind of inclination that perhaps research software in particular, is in a particular state, but we perhaps lack the evidence to demonstrate that it is well designed, that that's maintainable that's extensible, that in some ways, it's sustainable. This is, this is not the exact image that was shown to me, a couple of presentations that I was at, but one was in software architecture. And the other one was a guest lecture from a chief architecture, chief architects, leading UK bank, and he came along he says, This is our architecture of our system isn't a complex. And I say that I said it's not really complex is chaos. It's complicated. It's very difficult to understand. And I, this leads us to a couple of questions that leads us to the question, what do we mean by sustainability? In terms of software and software engineering? How do we measure whether our software is sustainable, and what might enable software to become sustainable? By and it brings us back to this horrible word. And we've been kicking this can down the road for some time. So this is a recent definition of the word sustainability in relationship to research software that is maintainable, sustainable, and robust. And somehow, this is the core quality of what constitutes sustainable software. I have real problems with this. Because first of all, I really don't understand what we mean by sustainability. And if you look back at the literature, going back to 2012, a lot of it is got to do with the fact that it is indeed considered a quality. But it's very difficult to pin that down.
 
I have some interesting views on perhaps where we're going with this in terms of how we might define it. And why is it important that we define what we mean? Well, I think of myself as not only as an academic, but as a software engineer. And as an engineer with the emphasis on the engineering part, I need to know and be able to demonstrate whether something is indeed maintainable. And that's something that we know how to do within the field of software engineering. The second question is how do we measure measure whether something is sustainable? This is a common response. When I kind of look at code quality is a useful measure is the number of WTF 's and if you don't know what that means, I will repeat it since this is being recorded. But you can look that up on the web somewhere divided by the number of minutes And it's an it's an indicator of what it is that we're dealing with, particularly in terms of this tangled web of software that we end up having to deal with whether that is green shoots of software, or whether it is Greenfield software or whether it is legacy brownfields stuff. How might we sort of enable this? Well, I came from the University of Leeds working at the architectural level. And there has been some discussion in the field about, you know, how we might enable sustainable software. It turns out that the field of software architecture, for the last 40 years has been dealing with the concept of sustainability. They just don't call it sustainability. They call it long living. And why are they interested in long living software? And what are they particularly interested in? Well, they're interested in things to do with things like architectural decay, Architectural Erosion, Architectural Drift, and whether the system that was designed has actually been implemented. The reason for this is that the software architecture provides the blueprint for understanding software quality. So if you want to understand maintainability as a concept, it's done at an architectural level. If you want to understand performance, or extensibility, or portability is done at an architectural level. Although saying something is maintainable or sustainable, or portable or interoperable, is meaningless, we have to think about what that really means. And an interesting thing about qualities is that they are not equal. So there is always an inherent trade off between the different types of qualities that we might want to use in any given system that we built. So sustainable software, I think, begins at an architectural level. Because we know how to design systems, we know how these systems communicate with each other. If you read the book by Bob Martin on clean architecture, she starts off with a case study. And this is a case study in architectural mess. And when you look at these two graphs, you can see that they are inverted at some point. So in release one, productivity is high, and the wage bill is low. By the time we get to release a productivity is flatlined. But the wage bill for the software engineering team has gone through the roof. That is a problem. And that is where we are both within Academic software and where we are within industry. Because of perhaps poor practice, and environmental factors, there are a whole range of different influences that get us into the state of technical debt, and how we can live with technical debt or die by technical debt. So I want you to sort of illustrate a lot of this around the Merlin project. So Merlin is collimation simulation software was developed originally in the early noughties, at the synchrotron in Germany. It has been ported to the Large Hadron Collider. We're interested in how the proton beam gets fired around the collider. Partly because beam Halo, which is a consequence of it not going through the lenses correctly, results in hardware damage that is perhaps irreversible. I think someone suggested that it was a beam halo that is out of control can melt one tonne of copper. So a significant impact on getting this wrong. So what do we do know we simulate how that actually operates? So it's been around for a considerable period of time.
 
This was the architecture in 2017. And you're looking at that slide going Colin there's nothing on the slide. And that's the point I want to make here is that when I spoke to the Merlin team, and I said what's your architecture? I was met with the usual blank stare. And then the inevitable question, what is an architecture and why is it important for the software that we're developing? Skip forward a couple of months and this is what we get. We get what we broadly considered to be architecture. So the guys were able to extract what the felt were meaningful components, they were able to try and understand, you know, the relationship between these particular types of components, and came up with this as a representation of what Merlin was, how it operated and how things were related to each other. Now, I was reminded the other week there an interesting quote, that all models are wrong. Some models are useful. And so it's a useful way of reasoning about the system we have designed, even if it's not an accurate representation of that. But I really wanted to understand what the actual architecture was. And this is the reality of it. So I've given you the sort of the broad view of what the architecture really kind of looks like. So we did some traditional static analysis on the code base, using well used metrics, you know, we got insight into complexity into dependencies into coupling into cohesion into the number of lines of code that were within all of this. But we were really interested in what was happening at the architectural level, because we were interested in the debt that existed at the architectural level. And so we applied a couple of different tools to this one would sooner graph and the other one was deviate, which comes out of the work of Rick Kasmin and young fan chi, Drexel, and University of Hawaii respectively. So it gives them a really insight into what the state of the Merlin architecture really was. And we found violations, we found flaws, we find improper inheritance, we find modular modularity violations, we find propagation change errors. There it was, these were non trivial problems. so I guess we run out of time. So what were the I think we are with sustainable software? Well, I think sustainable software is explicitly designed for continuous maintainability and evolvability without incurring prohibitive technical debt, the interesting challenges that we know how to do that, how do we actually get people to implement that and I want to leave you with this thought, Okay. For those of you who are familiar with Grady Booch, and he talks about building software systems, we set out to build skyscrapers, but take the approach to building a dog kennel. So thanks for listening.


