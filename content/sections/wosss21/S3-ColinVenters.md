# The Lost Architectures of Scientific Software and How to Find Them
**by Colin Venters**  

## From session 3 - [Human factors and new development in preserving and sustaining research software](/wosss21/agenda#session-3)  

### Resources
A [video](https://www.youtube.com/watch?v=yLYlUNY2kG8&list=PLXAvKzjdTsrxFqbjWtxHjfJc0RN6jMwZg&index=17) is available.

### Summary

Modern scientific and engineering research is highly dependent on software. Its importance in driving forward advances in research in the field of computational science and engineering has resulted in calls for it to be classified as a first-class experimental scientific instrument. However, software as a research instrument has not reached a level of maturity compared with the conventional tools of empirical and theoretical science (Goble, 2014). Why? Research software is principally developed by end-user developers who have a limited understanding and application of fundamental software engineering concepts, principles, and techniques, combined with a "code-first" approach to development, which is in part driven by the complexity and uncertainty of the problem. This results in research software with suboptimal software design, if any, leading to accidental complexity, technical debt, code smells, and an increase in the risk of software entropy. Similarly, while Research Software Engineering aims to facilitate the creation of well-designed, reliable, efficient software to solve research problems there is little empirical evidence to demonstrate that the research software created is well designed, if at all, understandable, maintainable and extensible. The consequences of accidental software complexity lead to a range of rotten symptoms, including software rigidity, fragility, immobility, and viscosity that are a pathway to stagnation, decay, and the long-term decline of essential research software investment (Booch, 2006).

Sustainability is generally understood as the capacity of a socio-technical system to endure (Becker et al. 2015). While a number of communities have attempted to address the challenges of achieving sustainability from their different perspectives, there is a severe lack of common understanding of the fundamental concepts of sustainability and how it relates to software systems. As a result, there is no agreed definition of software sustainability or how it might be achieved. While there have been a number of contributions to formalise a definition of software sustainability, the concept remains an elusive and ambiguous term with individuals, groups and organisations holding diametrically opposed views (Venters et al. 2014). This lack of clarity ultimately leads to confusion, and potentially to ineffective and inefficient efforts to develop sustainable software systems.

The future of scientific and engineering enterprise requires a resilient eco-system of software (Wiese, Polato and Pinto, 2020). Software design is a key component of sustainable software, which starts with software architecture (Durdik, 2012). Software architectures represent the set of structures required to reason about the system, which comprises both software elements, their properties and relationships (Bass, Clements, and Kazman, 2012). Software architecture is fundamental to the development of technically sustainable software as they lay the foundation for the successful implementation, maintenance and evolution of sustainable software systems in a continually changing execution environment by providing a mechanism for reasoning about core software quality requirements that contribute to sustainability as a first-class, composite software quality (van Vliet, 2008). By addressing software sustainability at the architectural level, it allows the inhibiting or enabling of systems quality attributes, reasoning about and managing change as the system evolves, predicting system qualities, as well as measuring architecturally significant requirements. However, the ability to determine sustainability as a core software quality of a software system from an architectural perspective remains an open research challenge, and existing architectural principles need to be adapted and novel architectural paradigms devised. In addition, there is a pressing need for new tooling to fit today's emergent and dynamic environments, where essential research software is explicitly designed for continuous evolvability and adaptability without incurring prohibitive architectural, technical debt (Northrop, 2018).

This micro-talk argues that sustainable software is that which is explicitly designed for continuous maintainability and evolvability without incurring prohibitive technical debt and a negative impact on the dimensions of sustainability and presents the results of a case study on the technical sustainability of the MERLIN++ particle accelerator tracking library originally developed in 2000 at Deutsches Elektronen-Synchrotron.

#### References

Bass, L. Clements, P. and Kazman, R. (2012). Software architecture in practice. Addison-Wesley.  
Becker et al. (2015). Sustainability design and software: The Karlskrona manifesto. ICSE 2015: 37th IEEE/ACM International Conference on Software Engineering, Florence, Italy; May 16-24, 2015.  
Booch, G. (2006). The accidental architecture. IEEE Software, 23 (3), pp. 9-11.  
Durdik, Z. (2012). Sustainability guidelines for long-living software systems, ICSM: 28th IEEE International Conference on Software Maintenance, Trento, 2012, pp. 517-526  
Goble, C. (2014). Better Software, Better Research, IEEE Internet Computing, 18 (5), pp. 4-8  
Northrop, L. (2018). Modern trends through an architecture lens. In: ICSE’18: 40th International Conference on Software Engineering Proceedings. May 27 – June 03, 2018, Gothenburg, Sweden, 2018  
van Vliet, H. (2008). Software engineering: Principles and practice, 3rd edition, Wiley  
Venters, C. C. et al. (2014). The blind men and the elephant: Towards an empirical evaluation framework for software sustainability, Journal of Open Research Software. 2 (1).  
Wiese, I. Polato I. and Pinto, G. (2020). Naming the pain in developing scientific software, IEEE Software, 37 (4), 75-82.

### Transcript

#### Keywords

architecture, software, architectural, sustainable, merlin, sustainability, maintainable, technical debt, leeds, quality, designed, university, tangled mess, understand, building, field, working, software engineering, software architecture, research

#### Text

My name is Colin, I'm from the University of Huddersfield. If you've looked in the sort of introduction section, you'll find out stuff about me. Two things I probably want to flag is that I am a founding member of the Karlskrona. manifesto, and co author of the, the manifesto that came out for XC. Zen would talk about the last architectures of scientific software and perhaps how we can find them. So I wanted to kind of begin this story a little bit around where my journey began. And I used to work at the University of Leeds many moons ago. And I decided I wanted a change of direction in both career and in some things, I was doing research. But I went the long distance across the Pennines, the University of Leeds working in the dependable Systems and Software Group. And I was working on a military project, which was about network centric warfare. But it was really a project about sustainability, but not sustainability in terms of how we think about sustainability. So we were thinking about things to do with lethality, we were thinking about quality, such as survivability of weapon systems, and the University of Leeds were principally responsible for thinking about how we architected this system, and how we were able to utilise and make more efficient use of different types of resources. So that's where my sort of journey in the field of sustainability really begins. There was an interesting blog post posted on the RSE Slack channel, some while ago, and it was entitled The shape of cool got tangled mess, or at least it was hinting at a tangled mess. And it was someone's position that research software, indeed, was a tangled mess. And that research software engineering would make no difference to this particular problem. What was quite interesting about that was from both positions, it was difficult to either support that position or refute it. There is always some kind of inclination that perhaps research software in particular, is in a particular state, but we perhaps lack the evidence to demonstrate that it is well designed, that that's maintainable that's extensible, that in some ways, it's sustainable. This is, this is not the exact image that was shown to me, a couple of presentations that I was at, but one was in software architecture. And the other one was a guest lecture from a chief architecture, chief architects, leading UK bank, and he came along he says, This is our architecture of our system isn't a complex. And I say that I said it's not really complex is chaos. It's complicated. It's very difficult to understand. And I, this leads us to a couple of questions that leads us to the question, what do we mean by sustainability? In terms of software and software engineering? How do we measure whether our software is sustainable, and what might enable software to become sustainable? By and it brings us back to this horrible word. And we've been kicking this can down the road for some time. So this is a recent definition of the word sustainability in relationship to research software that is maintainable, sustainable, and robust. And somehow, this is the core quality of what constitutes sustainable software. I have real problems with this. Because first of all, I really don't understand what we mean by sustainability. And if you look back at the literature, going back to 2012, a lot of it is got to do with the fact that it is indeed considered a quality. But it's very difficult to pin that down.
 
I have some interesting views on perhaps where we're going with this in terms of how we might define it. And why is it important that we define what we mean? Well, I think of myself as not only as an academic, but as a software engineer. And as an engineer with the emphasis on the engineering part, I need to know and be able to demonstrate whether something is indeed maintainable. And that's something that we know how to do within the field of software engineering. The second question is how do we measure measure whether something is sustainable? This is a common response. When I kind of look at code quality is a useful measure is the number of WTF 's and if you don't know what that means, I will repeat it since this is being recorded. But you can look that up on the web somewhere divided by the number of minutes And it's an it's an indicator of what it is that we're dealing with, particularly in terms of this tangled web of software that we end up having to deal with whether that is green shoots of software, or whether it is Greenfield software or whether it is legacy brownfields stuff. How might we sort of enable this? Well, I came from the University of Leeds working at the architectural level. And there has been some discussion in the field about, you know, how we might enable sustainable software. It turns out that the field of software architecture, for the last 40 years has been dealing with the concept of sustainability. They just don't call it sustainability. They call it long living. And why are they interested in long living software? And what are they particularly interested in? Well, they're interested in things to do with things like architectural decay, Architectural Erosion, Architectural Drift, and whether the system that was designed has actually been implemented. The reason for this is that the software architecture provides the blueprint for understanding software quality. So if you want to understand maintainability as a concept, it's done at an architectural level. If you want to understand performance, or extensibility, or portability is done at an architectural level. Although saying something is maintainable or sustainable, or portable or interoperable, is meaningless, we have to think about what that really means. And an interesting thing about qualities is that they are not equal. So there is always an inherent trade off between the different types of qualities that we might want to use in any given system that we built. So sustainable software, I think, begins at an architectural level. Because we know how to design systems, we know how these systems communicate with each other. If you read the book by Bob Martin on clean architecture, she starts off with a case study. And this is a case study in architectural mess. And when you look at these two graphs, you can see that they are inverted at some point. So in release one, productivity is high, and the wage bill is low. By the time we get to release a productivity is flatlined. But the wage bill for the software engineering team has gone through the roof. That is a problem. And that is where we are both within Academic software and where we are within industry. Because of perhaps poor practice, and environmental factors, there are a whole range of different influences that get us into the state of technical debt, and how we can live with technical debt or die by technical debt. So I want you to sort of illustrate a lot of this around the Merlin project. So Merlin is collimation simulation software was developed originally in the early noughties, at the synchrotron in Germany. It has been ported to the Large Hadron Collider. We're interested in how the proton beam gets fired around the collider. Partly because beam Halo, which is a consequence of it not going through the lenses correctly, results in hardware damage that is perhaps irreversible. I think someone suggested that it was a beam halo that is out of control can melt one tonne of copper. So a significant impact on getting this wrong. So what do we do know we simulate how that actually operates? So it's been around for a considerable period of time.
 
This was the architecture in 2017. And you're looking at that slide going Colin there's nothing on the slide. And that's the point I want to make here is that when I spoke to the Merlin team, and I said what's your architecture? I was met with the usual blank stare. And then the inevitable question, what is an architecture and why is it important for the software that we're developing? Skip forward a couple of months and this is what we get. We get what we broadly considered to be architecture. So the guys were able to extract what the felt were meaningful components, they were able to try and understand, you know, the relationship between these particular types of components, and came up with this as a representation of what Merlin was, how it operated and how things were related to each other. Now, I was reminded the other week there an interesting quote, that all models are wrong. Some models are useful. And so it's a useful way of reasoning about the system we have designed, even if it's not an accurate representation of that. But I really wanted to understand what the actual architecture was. And this is the reality of it. So I've given you the sort of the broad view of what the architecture really kind of looks like. So we did some traditional static analysis on the code base, using well used metrics, you know, we got insight into complexity into dependencies into coupling into cohesion into the number of lines of code that were within all of this. But we were really interested in what was happening at the architectural level, because we were interested in the debt that existed at the architectural level. And so we applied a couple of different tools to this one would sooner graph and the other one was deviate, which comes out of the work of Rick Kasmin and young fan chi, Drexel, and University of Hawaii respectively. So it gives them a really insight into what the state of the Merlin architecture really was. And we found violations, we found flaws, we find improper inheritance, we find modular modularity violations, we find propagation change errors. There it was, these were non trivial problems. so I guess we run out of time. So what were the I think we are with sustainable software? Well, I think sustainable software is explicitly designed for continuous maintainability and evolvability without incurring prohibitive technical debt, the interesting challenges that we know how to do that, how do we actually get people to implement that and I want to leave you with this thought, Okay. For those of you who are familiar with Grady Booch, and he talks about building software systems, we set out to build skyscrapers, but take the approach to building a dog kennel. So thanks for listening.


